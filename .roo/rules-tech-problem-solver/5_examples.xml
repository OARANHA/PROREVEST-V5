<practical_examples>
  <overview>
    Este documento contém exemplos práticos de resolução de problemas técnicos
    usando o modo Tech Problem Solver, demonstrando o fluxo de trabalho completo
    desde o diagnóstico até a implementação da solução.
  </overview>

  <example id="1" category="react_router_v7">
    <title>Resolvendo Problema de Roteamento Dinâmico com React Router v7</title>
    <problem_description>
      O usuário reporta que a página de detalhes do projeto não está funcionando.
      Ao acessar "/projects/123", a aplicação exibe uma página em branco em vez
      dos detalhes do projeto. Não há erros no console do navegador.
    </problem_description>
    
    <diagnosis_process>
      <step number="1">
        <action>Buscar por definições de rotas no projeto</action>
        <tool>codebase_search</tool>
        <query>createBrowserRouter routes projects</query>
      </step>
      
      <step number="2">
        <action>Examinar o arquivo de configuração de rotas</action>
        <tool>read_file</tool>
        <file>app/router.tsx</file>
      </step>
      
      <step number="3">
        <action>Verificar o componente de detalhes do projeto</action>
        <tool>read_file</tool>
        <file>app/routes/projects.$projectId.tsx</file>
      </step>
      
      <step number="4">
        <action>Identificar o problema: o componente não está usando o hook useParams para obter o ID do projeto</action>
      </step>
    </diagnosis_process>
    
    <solution_implementation>
      <step number="1">
        <action>Corrigir o componente para usar useParams e buscar os dados do projeto</action>
        <tool>apply_diff</tool>
        <file>app/routes/projects.$projectId.tsx</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>app/routes/projects.$projectId.tsx</path>
<diff>
<<<<<<< SEARCH
:start_line:1
-------
import { useState, useEffect } from 'react';

export default function ProjectDetail() {
  const [project, setProject] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Buscar dados do projeto
    fetch('/api/projects/123')
      .then(res => res.json())
      .then(data => {
        setProject(data);
        setLoading(false);
      });
  }, []);
  
  if (loading) return <div>Carregando...</div>;
  if (!project) return <div>Projeto não encontrado</div>;
  
  return (
    <div>
      <h1>{project.name}</h1>
      <p>{project.description}</p>
    </div>
  );
}
=======
import { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';

export default function ProjectDetail() {
  const { projectId } = useParams();
  const [project, setProject] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    if (!projectId) {
      setError('ID do projeto não fornecido');
      setLoading(false);
      return;
    }
    
    // Buscar dados do projeto usando o ID dinâmico
    fetch(`/api/projects/${projectId}`)
      .then(res => {
        if (!res.ok) {
          throw new Error('Projeto não encontrado');
        }
        return res.json();
      })
      .then(data => {
        setProject(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [projectId]);
  
  if (loading) return <div>Carregando...</div>;
  if (error) return <div>Erro: {error}</div>;
  if (!project) return <div>Projeto não encontrado</div>;
  
  return (
    <div>
      <h1>{project.name}</h1>
      <p>{project.description}</p>
    </div>
  );
}
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
      
      <step number="2">
        <action>Adicionar um loader para melhorar a experiência do usuário</action>
        <tool>apply_diff</tool>
        <file>app/routes/projects.$projectId.tsx</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>app/routes/projects.$projectId.tsx</path>
<diff>
<<<<<<< SEARCH
:start_line:1
-------
import { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';

export default function ProjectDetail() {
=======
import { useState, useEffect } from 'react';
import { useParams, useLoaderData } from 'react-router-dom';

// Loader para carregar os dados do projeto
export async function loader({ params }) {
  const { projectId } = params;
  
  if (!projectId) {
    throw new Response('ID do projeto não fornecido', { status: 400 });
  }
  
  const response = await fetch(`/api/projects/${projectId}`);
  
  if (!response.ok) {
    throw new Response('Projeto não encontrado', { status: 404 });
  }
  
  return response.json();
}

export default function ProjectDetail() {
  const project = useLoaderData();
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
      
      <step number="3">
        <action>Atualizar o router para incluir o loader</action>
        <tool>apply_diff</tool>
        <file>app/router.tsx</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>app/router.tsx</path>
<diff>
<<<<<<< SEARCH
:start_line:25
-------
      {
        path: "projects/:projectId",
        element: <ProjectDetail />
      }
=======
      {
        path: "projects/:projectId",
        element: <ProjectDetail />,
        loader: ProjectDetail.loader
      }
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
    </solution_implementation>
    
    <result>
      A página de detalhes do projeto agora funciona corretamente, exibindo
      as informações do projeto correspondente ao ID na URL. A implementação
      foi otimizada com o uso de loaders do React Router v7 para melhorar
      a experiência do usuário e o desempenho da aplicação.
    </result>
    
    <lessons_learned>
      <lesson>Componentes de rotas dinâmicas devem usar o hook useParams para acessar parâmetros da URL</lesson>
      <lesson>Loaders do React Router v7 são uma forma eficiente de carregar dados antes da renderização</lesson>
      <lesson>Tratamento adequado de erros melhora a experiência do usuário e facilita o debugging</lesson>
    </lessons_learned>
  </example>

  <example id="2" category="supabase_integration">
    <title>Resolvendo Problema de Autenticação com Supabase</title>
    <problem_description>
      O usuário reporta que após fazer login, a aplicação não mantém a sessão
      autenticada. Ao recarregar a página, o usuário é redirecionado para a
      página de login novamente, mesmo tendo feito login corretamente.
    </problem_description>
    
    <diagnosis_process>
      <step number="1">
        <action>Buscar por arquivos relacionados à autenticação</action>
        <tool>codebase_search</tool>
        <query>supabase auth login session</query>
      </step>
      
      <step number="2">
        <action>Examinar o provedor de autenticação</action>
        <tool>read_file</tool>
        <file>src/contexts/AuthContext.tsx</file>
      </step>
      
      <step number="3">
        <action>Verificar a configuração do cliente Supabase</action>
        <tool>read_file</tool>
        <file>src/lib/supabase.ts</file>
      </step>
      
      <step number="4">
        <action>Identificar o problema: o cliente Supabase não está configurado para persistir sessões</action>
      </step>
    </diagnosis_process>
    
    <solution_implementation>
      <step number="1">
        <action>Atualizar a configuração do cliente Supabase para persistir sessões</action>
        <tool>apply_diff</tool>
        <file>src/lib/supabase.ts</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>src/lib/supabase.ts</path>
<diff>
<<<<<<< SEARCH
:start_line:1
-------
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
=======
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true
  }
});
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
      
      <step number="2">
        <action>Atualizar o AuthContext para verificar a sessão ao inicializar</action>
        <tool>apply_diff</tool>
        <file>src/contexts/AuthContext.tsx</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>src/contexts/AuthContext.tsx</path>
<diff>
<<<<<<< SEARCH
:start_line:25
-------
  useEffect(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session) => {
        setUser(session?.user || null);
        setLoading(false);
      }
    );

    return () => subscription.unsubscribe();
  }, []);
=======
  useEffect(() => {
    // Verificar sessão existente ao carregar
    const checkSession = async () => {
      setLoading(true);
      const { data: { session } } = await supabase.auth.getSession();
      setUser(session?.user || null);
      setLoading(false);
    };
    
    checkSession();
    
    // Configurar listener para mudanças de autenticação
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session) => {
        setUser(session?.user || null);
        
        if (event === 'SIGNED_OUT') {
          // Limpar qualquer estado relacionado ao usuário
          localStorage.removeItem('user_preferences');
        }
      }
    );

    return () => subscription.unsubscribe();
  }, []);
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
      
      <step number="3">
        <action>Adicionar tratamento de erros no componente de login</action>
        <tool>apply_diff</tool>
        <file>src/components/LoginForm.tsx</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>src/components/LoginForm.tsx</path>
<diff>
<<<<<<< SEARCH
:start_line:35
-------
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    
    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password
      });
      
      if (error) {
        setError(error.message);
      } else {
        // Login bem-sucedido
        navigate('/dashboard');
      }
    } catch (err) {
      setError('Ocorreu um erro ao fazer login');
    } finally {
      setLoading(false);
    }
  };
=======
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    
    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password
      });
      
      if (error) {
        setError(error.message);
      } else if (data.user) {
        // Verificar se o email foi confirmado
        if (!data.user.email_confirmed_at) {
          setError('Por favor, confirme seu email antes de fazer login');
          await supabase.auth.signOut();
        } else {
          // Login bem-sucedido
          navigate('/dashboard');
        }
      }
    } catch (err) {
      setError('Ocorreu um erro ao fazer login');
      console.error('Login error:', err);
    } finally {
      setLoading(false);
    }
  };
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
    </solution_implementation>
    
    <result>
      A autenticação agora funciona corretamente, mantendo a sessão do usuário
      mesmo após recarregar a página. O sistema também verifica se o email foi
      confirmado antes de permitir o acesso, melhorando a segurança da aplicação.
    </result>
    
    <lessons_learned>
      <lesson>O cliente Supabase precisa ser configurado com persistSession: true para manter sessões</lesson>
      <lesson>É importante verificar a sessão existente ao inicializar a aplicação</lesson>
      <lesson>Tratamento adequado de erros e validações melhora a segurança e experiência do usuário</lesson>
    </lessons_learned>
  </example>

  <example id="3" category="ui_responsive">
    <title>Resolvendo Problema de Responsividade em Componentes de UI</title>
    <problem_description>
      O usuário reporta que o dashboard da aplicação não é responsivo em
      dispositivos móveis. Em telas pequenas, os elementos se sobrepõem e
      o layout fica quebrado, tornando a aplicação inutilizável.
    </problem_description>
    
    <diagnosis_process>
      <step number="1">
        <action>Buscar pelo componente do dashboard</action>
        <tool>codebase_search</tool>
        <query>dashboard component layout</query>
      </step>
      
      <step number="2">
        <action>Examinar o componente do dashboard</action>
        <tool>read_file</tool>
        <file>src/components/Dashboard.tsx</file>
      </step>
      
      <step number="3">
        <action>Verificar os estilos CSS aplicados ao componente</action>
        <tool>read_file</tool>
        <file>src/components/Dashboard.module.css</file>
      </step>
      
      <step number="4">
        <action>Identificar o problema: o layout usa larguras fixas e não tem media queries</action>
      </step>
    </diagnosis_process>
    
    <solution_implementation>
      <step number="1">
        <action>Atualizar o componente do dashboard para usar layout responsivo</action>
        <tool>apply_diff</tool>
        <file>src/components/Dashboard.tsx</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>src/components/Dashboard.tsx</path>
<diff>
<<<<<<< SEARCH
:start_line:1
-------
import React from 'react';
import styles from './Dashboard.module.css';

const Dashboard = () => {
  return (
    <div className={styles.container}>
      <div className={styles.sidebar}>
        <h2>Menu</h2>
        <ul>
          <li>Dashboard</li>
          <li>Projetos</li>
          <li>Relatórios</li>
          <li>Configurações</li>
        </ul>
      </div>
      <div className={styles.content}>
        <h1>Dashboard</h1>
        <div className={styles.cards}>
          <div className={styles.card}>
            <h3>Total de Projetos</h3>
            <p>24</p>
          </div>
          <div className={styles.card}>
            <h3>Tarefas Pendentes</h3>
            <p>12</p>
          </div>
          <div className={styles.card}>
            <h3>Membros da Equipe</h3>
            <p>8</p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Dashboard;
=======
import React, { useState } from 'react';
import styles from './Dashboard.module.css';

const Dashboard = () => {
  const [sidebarOpen, setSidebarOpen] = useState(false);

  return (
    <div className={styles.container}>
      <button 
        className={styles.menuButton}
        onClick={() => setSidebarOpen(!sidebarOpen)}
      >
        ☰
      </button>
      
      <div className={`${styles.sidebar} ${sidebarOpen ? styles.sidebarOpen : ''}`}>
        <div className={styles.sidebarHeader}>
          <h2>Menu</h2>
          <button 
            className={styles.closeButton}
            onClick={() => setSidebarOpen(false)}
          >
            ×
          </button>
        </div>
        <ul>
          <li>Dashboard</li>
          <li>Projetos</li>
          <li>Relatórios</li>
          <li>Configurações</li>
        </ul>
      </div>
      
      {sidebarOpen && (
        <div 
          className={styles.overlay}
          onClick={() => setSidebarOpen(false)}
        />
      )}
      
      <div className={styles.content}>
        <h1>Dashboard</h1>
        <div className={styles.cards}>
          <div className={styles.card}>
            <h3>Total de Projetos</h3>
            <p>24</p>
          </div>
          <div className={styles.card}>
            <h3>Tarefas Pendentes</h3>
            <p>12</p>
          </div>
          <div className={styles.card}>
            <h3>Membros da Equipe</h3>
            <p>8</p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Dashboard;
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
      
      <step number="2">
        <action>Atualizar os estilos CSS para serem responsivos</action>
        <tool>apply_diff</tool>
        <file>src/components/Dashboard.module.css</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>src/components/Dashboard.module.css</path>
<diff>
<<<<<<< SEARCH
:start_line:1
-------
.container {
  display: flex;
  height: 100vh;
}

.sidebar {
  width: 250px;
  background-color: #f8f9fa;
  padding: 20px;
  border-right: 1px solid #dee2e6;
}

.content {
  flex: 1;
  padding: 20px;
}

.cards {
  display: flex;
  gap: 20px;
  margin-top: 20px;
}

.card {
  background-color: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  width: 300px;
}
=======
.container {
  display: flex;
  height: 100vh;
  position: relative;
}

.menuButton {
  display: none;
  position: fixed;
  top: 15px;
  left: 15px;
  z-index: 1001;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 4px;
  width: 40px;
  height: 40px;
  font-size: 20px;
  cursor: pointer;
}

.sidebar {
  width: 250px;
  background-color: #f8f9fa;
  padding: 20px;
  border-right: 1px solid #dee2e6;
  transition: transform 0.3s ease;
}

.sidebarHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.closeButton {
  display: none;
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
}

.overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 999;
}

.content {
  flex: 1;
  padding: 20px;
}

.cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
  margin-top: 20px;
}

.card {
  background-color: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Media queries para responsividade */
@media (max-width: 768px) {
  .menuButton {
    display: block;
  }
  
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    height: 100vh;
    z-index: 1000;
    transform: translateX(-100%);
  }
  
  .sidebarOpen {
    transform: translateX(0);
  }
  
  .closeButton {
    display: block;
  }
  
  .overlay {
    display: block;
  }
  
  .content {
    padding: 70px 20px 20px;
  }
  
  .cards {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 480px) {
  .card {
    padding: 15px;
  }
}
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
    </solution_implementation>
    
    <result>
      O dashboard agora é totalmente responsivo, adaptando-se a diferentes
      tamanhos de tela. Em dispositivos móveis, a sidebar se transforma em
      um menu deslizante e os cards são reorganizados em uma única coluna
      para melhor legibilidade.
    </result>
    
    <lessons_learned>
      <lesson>Layouts responsivos devem usar unidades relativas e media queries</lesson>
      <lesson>Grid layouts são mais flexíveis que flexbox para designs responsivos</lesson>
      <lesson>Menus deslizantes são uma boa solução para navegação em telas pequenas</lesson>
      <lesson>Testar em diferentes tamanhos de tela é essencial para garantir uma boa experiência</lesson>
    </lessons_learned>
  </example>

  <example id="4" category="performance">
    <title>Otimizando Performance de Componentes React</title>
    <problem_description>
      O usuário reporta que a aplicação fica lenta e com travamentos ao
      exibir uma lista grande de itens (mais de 1000). O uso da CPU aumenta
      significativamente e a interface se torna não responsiva.
    </problem_description>
    
    <diagnosis_process>
      <step number="1">
        <action>Buscar pelo componente que renderiza a lista grande</action>
        <tool>codebase_search</tool>
        <query>list items map render large</query>
      </step>
      
      <step number="2">
        <action>Examinar o componente da lista</action>
        <tool>read_file</tool>
        <file>src/components/LargeItemList.tsx</file>
      </step>
      
      <step number="3">
        <action>Verificar como os dados são obtidos e processados</action>
        <tool>read_file</tool>
        <file>src/hooks/useItems.ts</file>
      </step>
      
      <step number="4">
        <action>Identificar o problema: renderização de todos os itens de uma vez sem otimização</action>
      </step>
    </diagnosis_process>
    
    <solution_implementation>
      <step number="1">
        <action>Implementar virtualização da lista com react-window</action>
        <tool>apply_diff</tool>
        <file>src/components/LargeItemList.tsx</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>src/components/LargeItemList.tsx</path>
<diff>
<<<<<<< SEARCH
:start_line:1
-------
import React, { useState, useEffect } from 'react';
import { useItems } from '../hooks/useItems';
import ItemCard from './ItemCard';

const LargeItemList = () => {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState('');
  
  useEffect(() => {
    const fetchItems = async () => {
      setLoading(true);
      const data = await useItems();
      setItems(data);
      setLoading(false);
    };
    
    fetchItems();
  }, []);
  
  const filteredItems = items.filter(item => 
    item.name.toLowerCase().includes(filter.toLowerCase())
  );
  
  if (loading) return <div>Carregando...</div>;
  
  return (
    <div>
      <input
        type="text"
        placeholder="Filtrar itens..."
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        className="filter-input"
      />
      <div className="items-list">
        {filteredItems.map(item => (
          <ItemCard key={item.id} item={item} />
        ))}
      </div>
    </div>
  );
};

export default LargeItemList;
=======
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { FixedSizeList as List } from 'react-window';
import { useItems } from '../hooks/useItems';
import ItemCard from './ItemCard';

const LargeItemList = () => {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState('');
  
  useEffect(() => {
    const fetchItems = async () => {
      setLoading(true);
      const data = await useItems();
      setItems(data);
      setLoading(false);
    };
    
    fetchItems();
  }, []);
  
  // Memoizar a filtragem para evitar recálculos desnecessários
  const filteredItems = useMemo(() => {
    return items.filter(item => 
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [items, filter]);
  
  // Memoizar o componente de item para evitar re-renderizações
  const Row = useCallback(({ index, style }) => (
    <div style={style}>
      <ItemCard item={filteredItems[index]} />
    </div>
  ), [filteredItems]);
  
  if (loading) return <div>Carregando...</div>;
  
  return (
    <div>
      <input
        type="text"
        placeholder="Filtrar itens..."
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        className="filter-input"
      />
      
      {filteredItems.length > 0 ? (
        <List
          height={600}
          itemCount={filteredItems.length}
          itemSize={150}
          width="100%"
        >
          {Row}
        </List>
      ) : (
        <div>Nenhum item encontrado</div>
      )}
    </div>
  );
};

export default LargeItemList;
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
      
      <step number="2">
        <action>Otimizar o hook useItems para evitar buscas desnecessárias</action>
        <tool>apply_diff</tool>
        <file>src/hooks/useItems.ts</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>src/hooks/useItems.ts</path>
<diff>
<<<<<<< SEARCH
:start_line:1
-------
import { useState, useEffect } from 'react';

export const useItems = async () => {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const fetchItems = async () => {
      setLoading(true);
      const response = await fetch('/api/items');
      const data = await response.json();
      setItems(data);
      setLoading(false);
    };
    
    fetchItems();
  }, []);
  
  return items;
};
=======
import { useState, useEffect, useCallback } from 'react';

// Cache para evitar requisições duplicadas
const itemsCache = new Map();
let lastFetchTime = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutos

export const useItems = () => {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  const fetchItems = useCallback(async () => {
    const now = Date.now();
    
    // Verificar se temos dados em cache válidos
    if (itemsCache.has('items') && now - lastFetchTime < CACHE_DURATION) {
      setItems(itemsCache.get('items'));
      setLoading(false);
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const response = await fetch('/api/items');
      
      if (!response.ok) {
        throw new Error(`Erro ao buscar itens: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Atualizar cache
      itemsCache.set('items', data);
      lastFetchTime = now;
      
      setItems(data);
    } catch (err) {
      setError(err.message);
      console.error('Erro ao buscar itens:', err);
    } finally {
      setLoading(false);
    }
  }, []);
  
  useEffect(() => {
    fetchItems();
  }, [fetchItems]);
  
  return { items, loading, error, refetch: fetchItems };
};
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
      
      <step number="3">
        <action>Otimizar o componente ItemCard com memoização</action>
        <tool>apply_diff</tool>
        <file>src/components/ItemCard.tsx</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>src/components/ItemCard.tsx</path>
<diff>
<<<<<<< SEARCH
:start_line:1
-------
import React from 'react';

const ItemCard = ({ item }) => {
  return (
    <div className="item-card">
      <h3>{item.name}</h3>
      <p>{item.description}</p>
      <div className="item-meta">
        <span>Categoria: {item.category}</span>
        <span>Preço: ${item.price.toFixed(2)}</span>
      </div>
    </div>
  );
};

export default ItemCard;
=======
import React, { memo } from 'react';

interface ItemCardProps {
  item: {
    id: string;
    name: string;
    description: string;
    category: string;
    price: number;
  };
}

const ItemCard = memo(({ item }: ItemCardProps) => {
  return (
    <div className="item-card">
      <h3>{item.name}</h3>
      <p>{item.description}</p>
      <div className="item-meta">
        <span>Categoria: {item.category}</span>
        <span>Preço: ${item.price.toFixed(2)}</span>
      </div>
    </div>
  );
});

export default ItemCard;
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
    </solution_implementation>
    
    <result>
      A lista grande de itens agora é renderizada de forma eficiente usando
      virtualização, reduzindo significativamente o uso de memória e CPU.
      A aplicação se tornou responsiva mesmo com milhares de itens, e o
      cache de dados evita requisições desnecessárias à API.
    </result>
    
    <lessons_learned>
      <lesson>Virtualização é essencial para renderizar listas grandes de forma eficiente</lesson>
      <lesson>Memoização de componentes e cálculos evita renderizações desnecessárias</lesson>
      <lesson>Cache de dados reduz o número de requisições e melhora a performance</lesson>
      <lesson>O uso de useCallback e useMemo é importante para otimizar componentes React</lesson>
    </lessons_learned>
  </example>

  <example id="5" category="error_handling">
    <title>Implementando Tratamento Centralizado de Erros</title>
    <problem_description>
      O usuário reporta que a aplicação apresenta falhas frequentes sem
      mensagens de erro claras. Quando ocorre um erro, a aplicação simplesmente
      fica em branco ou trava, sem fornecer feedback ao usuário.
    </problem_description>
    
    <diagnosis_process>
      <step number="1">
        <action>Buscar por componentes que podem causar erros</action>
        <tool>codebase_search</tool>
        <query>fetch api error handling</query>
      </step>
      
      <step number="2">
        <action>Examinar como os erros são tratados atualmente</action>
        <tool>read_file</tool>
        <file>src/services/api.ts</file>
      </step>
      
      <step number="3">
        <action>Verificar se há Error Boundaries na aplicação</action>
        <tool>codebase_search</tool>
        <query>ErrorBoundary componentDidCatch</query>
      </step>
      
      <step number="4">
        <action>Identificar o problema: falta de tratamento centralizado de erros</action>
      </step>
    </diagnosis_process>
    
    <solution_implementation>
      <step number="1">
        <action>Criar um componente ErrorBoundary personalizado</action>
        <tool>write_to_file</tool>
        <file>src/components/ErrorBoundary.tsx</file>
        <content>
          <![CDATA[
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error: Error): Partial<State> {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({
      error,
      errorInfo
    });
    
    // Registrar erro em serviço de monitoramento
    console.error('ErrorBoundary capturou um erro:', error, errorInfo);
    
    // Aqui você poderia enviar o erro para um serviço como Sentry, LogRocket, etc.
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      
      return (
        <div className="error-boundary-fallback">
          <h2>Algo deu errado</h2>
          <p>Ocorreu um erro inesperado na aplicação.</p>
          
          {process.env.NODE_ENV === 'development' && this.state.error && (
            <details className="error-details">
              <summary>Detalhes do erro (apenas desenvolvimento)</summary>
              <p>{this.state.error.toString()}</p>
              <pre>{this.state.errorInfo?.componentStack}</pre>
            </details>
          )}
          
          <div className="error-actions">
            <button onClick={this.handleReset}>
              Tentar novamente
            </button>
            <button onClick={() => window.location.reload()}>
              Recarregar página
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
          ]]>
        </content>
      </step>
      
      <step number="2">
        <action>Criar um hook para notificações de erro</action>
        <tool>write_to_file</tool>
        <file>src/hooks/useToast.ts</file>
        <content>
          <![CDATA[
import { useState, useCallback } from 'react';

interface Toast {
  id: string;
  message: string;
  type: 'success' | 'error' | 'warning' | 'info';
  duration?: number;
}

export function useToast() {
  const [toasts, setToasts] = useState<Toast[]>([]);
  
  const showToast = useCallback((
    message: string, 
    type: Toast['type'] = 'info', 
    duration = 5000
  ) => {
    const id = Math.random().toString(36).substr(2, 9);
    const newToast: Toast = { id, message, type, duration };
    
    setToasts(prev => [...prev, newToast]);
    
    // Remover toast automaticamente após a duração
    setTimeout(() => {
      removeToast(id);
    }, duration);
  }, []);
  
  const removeToast = useCallback((id: string) => {
    setToasts(prev => prev.filter(toast => toast.id !== id));
  }, []);
  
  return { toasts, showToast, removeToast };
}

export default useToast;
          ]]>
        </content>
      </step>
      
      <step number="3">
        <action>Criar um componente ToastContainer</action>
        <tool>write_to_file</tool>
        <file>src/components/ToastContainer.tsx</file>
        <content>
          <![CDATA[
import React from 'react';
import { useToast } from '../hooks/useToast';

const ToastContainer = () => {
  const { toasts, removeToast } = useToast();
  
  return (
    <div className="toast-container">
      {toasts.map(toast => (
        <div 
          key={toast.id}
          className={`toast toast-${toast.type}`}
          onClick={() => removeToast(toast.id)}
        >
          <div className="toast-message">
            {toast.message}
          </div>
          <button className="toast-close">
            ×
          </button>
        </div>
      ))}
    </div>
  );
};

export default ToastContainer;
          ]]>
        </content>
      </step>
      
      <step number="4">
        <action>Atualizar o serviço de API para incluir tratamento de erros</action>
        <tool>apply_diff</tool>
        <file>src/services/api.ts</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>src/services/api.ts</path>
<diff>
<<<<<<< SEARCH
:start_line:1
-------
import axios from 'axios';

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
});

export default api;
=======
import axios, { AxiosError } from 'axios';
import { useToast } from '../hooks/useToast';

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  timeout: 10000,
});

// Interceptor de requisição
api.interceptors.request.use(
  (config) => {
    // Adicionar token de autenticação
    const token = localStorage.getItem('auth_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Interceptor de resposta
api.interceptors.response.use(
  (response) => {
    return response;
  },
  (error: AxiosError) => {
    // Obter instância do toast (precisa ser chamado dentro de um componente React)
    // Esta é uma abordagem simplificada - em uma aplicação real, você usaria um contexto ou store
    
    // Tratar diferentes tipos de erro
    if (error.response) {
      // Erro de resposta do servidor (4xx, 5xx)
      switch (error.response.status) {
        case 401:
          // Não autorizado - redirecionar para login
          window.location.href = '/login';
          break;
        case 403:
          // Proibido - mostrar mensagem de permissão negada
          console.error('Permissão negada:', error.response.data);
          break;
        case 404:
          // Não encontrado - mostrar mensagem de recurso não encontrado
          console.error('Recurso não encontrado:', error.response.data);
          break;
        case 500:
          // Erro interno do servidor - mostrar mensagem genérica
          console.error('Erro interno do servidor:', error.response.data);
          break;
        default:
          // Outros erros
          console.error('Erro na requisição:', error.response.data);
      }
    } else if (error.request) {
      // Erro de requisição (sem resposta)
      console.error('Erro de conexão com o servidor');
    } else {
      // Erro de configuração
      console.error('Erro ao configurar requisição:', error.message);
    }
    
    return Promise.reject(error);
  }
);

export default api;
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
      
      <step number="5">
        <action>Envolver a aplicação com ErrorBoundary e ToastContainer</action>
        <tool>apply_diff</tool>
        <file>src/App.tsx</file>
        <diff>
          <![CDATA[
<apply_diff>
<path>src/App.tsx</path>
<diff>
<<<<<<< SEARCH
:start_line:1
-------
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import HomePage from './pages/HomePage';
import DashboardPage from './pages/DashboardPage';
import NotFoundPage from './pages/NotFoundPage';

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/dashboard" element={<DashboardPage />} />
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </Router>
  );
}

export default App;
=======
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import ErrorBoundary from './components/ErrorBoundary';
import ToastContainer from './components/ToastContainer';
import HomePage from './pages/HomePage';
import DashboardPage from './pages/DashboardPage';
import NotFoundPage from './pages/NotFoundPage';

function App() {
  return (
    <ErrorBoundary>
      <Router>
        <div className="app">
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/dashboard" element={<DashboardPage />} />
            <Route path="*" element={<NotFoundPage />} />
          </Routes>
          <ToastContainer />
        </div>
      </Router>
    </ErrorBoundary>
  );
}

export default App;
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]>
        </diff>
      </step>
    </solution_implementation>
    
    <result>
      A aplicação agora possui um tratamento de erros robusto e centralizado.
      Quando ocorre um erro, o usuário recebe feedback claro através de toasts
      ou da interface do ErrorBoundary. A aplicação não trava mais e oferece
      opções para recuperação, como tentar novamente ou recarregar a página.
    </result>
    
    <lessons_learned>
      <lesson>Error Boundaries são essenciais para capturar erros em componentes React</lesson>
      <lesson>Interceptores de API permitem tratamento centralizado de erros de rede</lesson>
      <lesson>Notificações de toast fornecem feedback claro ao usuário sobre erros</lesson>
      <lesson>Registrar erros em serviços de monitoramento facilita o debugging</lesson>
    </lessons_learned>
  </example>
</practical_examples>